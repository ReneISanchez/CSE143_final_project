--------------------------------------------------------------
--------------------------------------------------------------
--                                                          --
-- This VHDL file has been generated by the verilog2vhdl    --
-- tool.                                                    --
-- Contact help@edautils.com  for support/info.--
--                                                          --
--                                                          --
--------------------------------------------------------------
--------------------------------------------------------------
--
--
-- Assumptions: 
--         (1) All the parameters are of type INTEGER, and hence the translated generics are of this type
--
--
-- Generated by : kermit on 2/18/16 5:34 PM
--
--
library ieee;
use ieee.numeric_std.all;
use ieee.std_logic_1164.all;
package vl2vh_common_pack is 
    type vl2vh_memory_type is      array  ( natural range <> , natural range <>  )  of std_logic ;
    function vl2vh_ternary_func(  constant cond : Boolean;  constant trueval : std_logic;  constant falseval : std_logic)  return std_logic; 
    function vl2vh_ternary_func(  constant cond : Boolean;  constant trueval : std_logic_vector;  constant falseval : std_logic_vector)  return std_logic_vector; 
end package; 




package body vl2vh_common_pack is 
    function vl2vh_ternary_func(  constant cond : Boolean;  constant trueval : std_logic;  constant falseval : std_logic)  return std_logic is 
    begin
        if ( cond ) then 
             return trueval;
        else 
             return falseval;
        end if;
    end;
    function vl2vh_ternary_func(  constant cond : Boolean;  constant trueval : std_logic_vector;  constant falseval : std_logic_vector)  return std_logic_vector is 
    begin
        if ( cond ) then 
             return trueval;
        else 
             return falseval;
        end if;
    end;
end; 


library ieee;
library work;
use ieee.std_logic_1164.all;
use ieee.std_logic_misc.all;
use ieee.numeric_std.all;
use work.vl2vh_common_pack.all;
entity I2CslaveWith8bitsIO is 
generic (
        I2C_ADR : INTEGER := 39 
    );
     port (
        SDA :  inout std_logic;
        SCL :  in std_logic;
        IOout :  out std_logic_vector( 7  downto 0  )
    );
end entity; 


architecture rtl of I2CslaveWith8bitsIO is 
    signal SDA_shadow : std_logic;
    signal start_or_stop : std_logic;
    signal incycle : std_logic;
    signal bitcnt : std_logic_vector( 3  downto 0  );
    signal bit_DATA : std_logic := (  not bitcnt(3 ) ) ;
    signal bit_ACK : std_logic := bitcnt(3 );
    signal data_phase : std_logic;
    signal adr_phase : std_logic := (  not data_phase ) ;
    signal adr_match : std_logic;
    signal op_read : std_logic;
    signal got_ACK : std_logic;
    signal SDAr : std_logic;
    signal mem : std_logic_vector( 7  downto 0  );
    signal op_write : std_logic := (  not op_read ) ;
    signal subsetBitcnt : std_logic_vector := (bitcnt(2 downto 0));
    signal memInt : natural := (to_integer(unsigned(subsetBitcnt)));
    signal mem_bit_low : std_logic := (not mem(memInt));
    signal SDA_assert_low : std_logic := ( ( ( ( ( adr_match and bit_DATA )  and data_phase )  and op_read )  and mem_bit_low )  and got_ACK ) ;
    signal SDA_assert_ACK : std_logic := ( ( adr_match and bit_ACK )  and ( adr_phase or op_write )  ) ;
    signal SDA_low : std_logic := ( SDA_assert_low or SDA_assert_ACK ) ;
    begin 
        SDA_shadow <= vl2vh_ternary_func( ( (  not SCL )  or
		  start_or_stop ) , SDA, SDA_shadow );
        start_or_stop <= vl2vh_ternary_func( (  not SCL ) , '0', ( SDA xor SDA_shadow )  );
        process 
        begin
            wait until ( ( start_or_stop'EVENT and ( start_or_stop = '1' )  )  or ( SCL'EVENT and ( SCL = '0' )  )  ) ;
            if ( start_or_stop ) then 
                incycle <= '0';
            else 
                if ( (  not SDA )  ) then 
                    incycle <= '1';
                end if;
            end if;
        end process;
        process 
        begin
            wait until ( ( incycle'EVENT and ( incycle = '0' )  )  or ( SCL'EVENT and ( SCL = '0' )  )  ) ;
            if ( (  not incycle )  ) then 
                bitcnt <= X"7" ;
                data_phase <= 0 ;
            else 
                if ( bit_ACK ) then 
                    bitcnt <= X"7" ;
                    data_phase <= 1 ;
                else 
                    bitcnt <= ( bitcnt - X"1"  ) ;
                end if;
            end if;
        end process;
        process 
        begin
            wait until ( SCL'EVENT and ( SCL = '1' )  ) ;
            SDAr <= SDA;
        end process;
        process 
        begin
            wait until ( ( incycle'EVENT and ( incycle = '0' )  )  or ( SCL'EVENT and ( SCL = '0' )  )  ) ;
            if ( (  not incycle )  ) then 
                got_ACK <= 0 ;
                adr_match <= 1 ;
                op_read <= 0 ;
            else 
                if ( ( ( adr_phase and ( bitcnt = 7  )  )  and ( SDAr /= I2C_ADR(6 ) )  )  ) then 
                    adr_match <= 0 ;
                end if;
                if ( ( ( adr_phase and ( bitcnt = 6  )  )  and ( SDAr /= I2C_ADR(5 ) )  )  ) then 
                    adr_match <= 0 ;
                end if;
                if ( ( ( adr_phase and ( bitcnt = 5  )  )  and ( SDAr /= I2C_ADR(4 ) )  )  ) then 
                    adr_match <= 0 ;
                end if;
                if ( ( ( adr_phase and ( bitcnt = 4  )  )  and ( SDAr /= I2C_ADR(3 ) )  )  ) then 
                    adr_match <= 0 ;
                end if;
                if ( ( ( adr_phase and ( bitcnt = 3  )  )  and ( SDAr /= I2C_ADR(2 ) )  )  ) then 
                    adr_match <= 0 ;
                end if;
                if ( ( ( adr_phase and ( bitcnt = 2  )  )  and ( SDAr /= I2C_ADR(1 ) )  )  ) then 
                    adr_match <= 0 ;
                end if;
                if ( ( ( adr_phase and ( bitcnt = 1  )  )  and ( SDAr /= I2C_ADR(0 ) )  )  ) then 
                    adr_match <= 0 ;
                end if;
                if ( ( adr_phase and ( bitcnt = 0  )  )  ) then 
                    op_read <= SDAr;
                end if;
                if ( bit_ACK ) then 
                    got_ACK <= (  not SDAr ) ;
                end if;
                if ( ( ( ( adr_match and bit_DATA )  and data_phase )  and op_write )  ) then 
                    mem(bitcnt) <= SDAr;
                end if;
            end if;
        end process;
        SDA <= vl2vh_ternary_func( SDA_low, '0', 'z' );
        IOout <= mem;
    end; 


